# Функции - универсальная часть кода, которую можно использовать несколько раз (ака большие переменные).
# Функции делают для вещей, которые: 1) повторяются в разных частях кода, 2) повторяются с разными типами данных
# print(), input(), int() - тоже функции, но если нам надо что-то дополнительно, мы можем их создать сами.
# Для каждой функции желательно писать аннотацию - объяснение, что выполняет функция.

global A  # глобальная переменная, можем использовать внутри функций и снаружи
A = int(input())


# обычная функция, которая возвращает значения типа int
def summary(b: int) -> int:
    """Возвращает сумму числа с глобальной переменной"""
    # пишем объяснение, что делает наша функция - тут надо ответить на вопрос "Что функция делает?"

    return A + b  # return значит, что там, где мы будем использоваться нашу функцию, будет подставляться сумма А и b
# b - внутренняя переменная, уже на этой строке компьютер не будет знать, чему она равна и что это вообще


def change_number(b: int) -> int:  # вторая функция
    """Возвращает сумму внутренней переменны и функции summary"""
    return b + summary(b)  # мы можем использоваться одну функцию в другой


def change_global_number(b: float) -> None:  # None означает, что мы ничего не будет возвращать, как print()
    """Меняет значение глобальной переменной"""
    global A  # используем глобальную переменную, её надо объявить, чтобы использовать
    A += b  # После этого изменится переменная? Следующая строка поможет это проверить


change_number(5)  # вызываем функции вот так
print(summary(6))  # если мы используем функции с return, то они сами в консоль ничего не выпишут
print(change_number(90))  # в скобках надо использовать параметры, которые мы задали при создании функции


# рекурсия - функция вызывает саму себя
def recursion(a: int, b: int) -> int:
    """Выводит максимальное число с помощью рекурсии"""
    if a == 0 and b == 0:
        return 0  # в рекурсиях return пишут обычно несколько раз, потому что иначе будет бесконечный вызов самой себя

    a -= 1 if a > 0 else 0  # меняем какие-то параметры, типа наша функция делает что-то полезное и подсчитывает
    b -= 1 if b > 0 else 0

    return recursion(a, b) + 1  # функция будет продолжать вызывать себя, пока не сработает return раньше
# Чтобы не забывать, что мы должны доделать выполнение начальных частей рекурсии (повторить действие несколько раз),
# Python использует для этого стек - память компьютера, которая сохраняет в себя временный ответ на вызов функции,
# пока программа считает ответ в этой, более глубокой функции - рекурсии
# Стек в Python может сохранять максимум 1025 вызовов функций
